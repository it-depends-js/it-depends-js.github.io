{"name":"it-depends","tagline":"Lightweight dependency tracking library for JavaScript","body":"[![Build status](https://ci.appveyor.com/api/projects/status/dufdv2sefowej3mq/branch/master?svg=true)](https://ci.appveyor.com/project/gerich-home/it-depends/branch/master)\r\n[![Coverage Status](https://coveralls.io/repos/github/gerich-home/it-depends/badge.svg?branch=master)](https://coveralls.io/github/gerich-home/it-depends?branch=master)\r\n[![npm version](https://badge.fury.io/js/it-depends.svg)](https://badge.fury.io/js/it-depends)\r\n[![Dependency Status](https://david-dm.org/gerich-home/it-depends.svg)](https://david-dm.org/gerich-home/it-depends)\r\n[![devDependency Status](https://david-dm.org/gerich-home/it-depends/dev-status.svg)](https://david-dm.org/gerich-home/it-depends#info=devDependencies)\r\n[![Code Climate](https://codeclimate.com/github/gerich-home/it-depends/badges/gpa.svg)](https://codeclimate.com/github/gerich-home/it-depends)\r\n\r\n# it-depends\r\nLightweight dependency tracking / caching library for JavaScript\r\n\r\n## About the library\r\n**it-depends** library is the attempt to create a lightweight dependency tracking library that helps you organize your JavaScript code using the approach to build a model proposed in [KnockoutJS](http://knockoutjs.com/documentation/computedObservables.html)\r\n\r\n**it-depends** does not worry about UI - it is solely for managing dependencies between data/model elements.\r\n\r\nThe key point in using the library is to define as less **state values** as possible and define the rest of the model as **computed values**, based on them.\r\n\r\nAll computed values are **lazy** and **cacheable**. It means that if you define the computed value based on other values it is not calculated immediately.\r\n\r\nThe calculation function **will be called** on the **first** attempt to read the value.\r\n\r\nThe calculation function **will not be called** immediately after the value of any dependency is changed.\r\nYou **must read** the value again to trigger the execution of calculation function.\r\n\r\n## When to use?\r\nYour code has quite a little state and a lot of values that can be computed from this state.\r\n\r\nYour aim is to have easy to test, debug and maintain self-describing pieces of code **without side effects**.\r\nYou are OK with building code that way (it looks similar to [Functional Programming](https://en.wikipedia.org/wiki/Functional_programming)).\r\n\r\nYou have some state that should be calculated on demand only and you do not want to clutter your code with additional caching logic.\r\n\r\nYou use a framework that is responsible for rendering the model on the screen.\r\n\r\nLimitation(**to be removed**): the framework is built in Angular way - it makes decisions when it is better to query data from the model by itself and **does not require** you to notify that some value has changed (see #3, #5 - when they will be implemented, the limitation will be removed)\r\n\r\n## History\r\nI created the library when I was refactoring one of complex screens in an [AngularJS](https://angularjs.org/) application.\r\n\r\nThe corresponding UI code contained logic to handle the checked/unchecked state of checkboxes mixed with the quite complex business rules for calculating whether the checkbox is enabled or disabled (based on the checked/unchecked state).\r\n\r\nThe code was slow because for any (even unrelated to checkboxes) change on UI Angular restarted `$digest` loop and required the checked and enabled states.\r\nI preferred to do not use `$scope.$watch` to update values on change in checked/unchecked state, because I did not want to clutter my scope with implementation details of intermediate values, I wanted to always have some exact state (without intermediate transition states, when some values were updated and some of them - not) and I did not want to manage dependencies manually.\r\n\r\nI refactored code to extract these calculation functions into small pieces, implicitly declared dependencies between them, so the framework became able to handle both dependencies and caching for me.\r\n\r\nAfter that I allowed AngularJS to query my `$scope` so that it could get actual values from observable values and cached computed. \r\n\r\n## Installation and usage\r\n\r\n#### [NodeJS](https://nodejs.org/)\r\n\r\n```\r\nnpm install it-depends\r\n```\r\n\r\nIn your application include the module and use it:\r\n```javascript\r\nvar itDepends = require('it-depends');\r\n\r\n// your code goes here:\r\nvar firstName = itDepends.value('James');\r\n...\r\n```\r\n\r\n#### [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)/[RequireJS](http://requirejs.org/)\r\n\r\nDownload the [latest release](https://github.com/gerich-home/it-depends/releases)\r\n\r\nPlace where it is suitable according to your AMD/RequireJS configuration\r\n\r\nUse it as a dependency of AMD module:\r\n```javascript\r\ndefine(['it-depends'], function(itDepends) {\r\n    // your code goes here:\r\n    var firstName = itDepends.value('James');\r\n    ...\r\n});\r\n```\r\n\r\n#### Browser globals\r\n\r\nDownload the [latest release](https://github.com/gerich-home/it-depends/releases)\r\n\r\nPlace where it is suitable\r\n\r\nInclude it into the page:\r\n```html\r\n<script src=\"js/ext/it-depends.js\"></script>\r\n<script src=\"js/your-application.js\"></script>\r\n```\r\n\r\nYou will be able to use `itDepends` global variable in your-application.js:\r\n```javascript\r\n// your code goes here:\r\nvar firstName = itDepends.value('James');\r\n...\r\n```\r\n\r\n## API\r\n\r\n### `itDepends.value(initialValue)`\r\n\r\nCreates observable value object.\r\n\r\n#### Parameters:\r\n* `initialValue` *(optional, any value, undefined by default)* - the value to be stored in the observable when created.\r\n\r\n#### Returns:\r\nthe `observable` value object.\r\n\r\n### `observableValue()`\r\nReads the current value of observable value object.\r\n\r\n#### Returns:\r\nthe current value of observable value object.\r\n\r\n### `observableValue.write(newValue)`\r\nUpdates the current value of observable value object.\r\n\r\n#### Parameters:\r\n* `newValue` *(mandatory, any value)* - the new value to write to observable value object.\r\n\r\n#### Returns:\r\n*void*\r\n\r\n### `itDepends.computed(calculator)`\r\nCreates computed value object.\r\n\r\n#### Parameters:\r\n* `calculator` *(mandatory, function (...parameters: any[]) -> any)* - the function that will be called later to (re)calculate the value of computed. Gets called when you request the value for the first time, or when you request the value when some of dependencies (values/computeds) was changed. Should return(calculate) the current value of the computed value object. **Must not** have side-effects. Calculator function can take parameters. In this case the resulting computed behaves as a set of elementary computeds bound to each distinct set of arguments.\r\n\r\n#### Returns:\r\nthe `computed` value object.\r\n\r\n### `computedValue(...parameters)`\r\nReads the current value of computed value object for the given set of parameters. `calculator` will be called if it is the first call or if a change was made to some of the dependencies (values/computeds) called from calculator previous time. Otherwise the cached current value will be returned.\r\nDuring the call dependencies (values/computeds) used in the calculator will be recorded and stored in the list of dependencies.\r\n\r\n#### Parameters:\r\n* `parameters` *(varadic, any[])* - parameters that will be passed to the `calculator`. Calculator will be called only once for each unique set of parameters unless dependencies are changed. \r\n\r\n#### Returns:\r\nthe current value of computed value object for the given parameters.\r\n\r\n### `itDepends.promiseValue(promise, initialValue)`\r\n\r\nCreates promise value wrapper object.\r\n\r\n#### Parameters:\r\n* `promise` *(mandatory, [Promise](https://promisesaplus.com/#point-21))* - the promise object that is the source of the value.\r\n* `initialValue` *(optional, any, undefined by default)* - the value to be stored in the promise value when created.\r\n\r\n#### Returns:\r\nthe `promise` value object filled with the `initialValue` or `undefined` if none specified.\r\nDepending on the concrete Promise implementation can be filled with the value of a Promise if it was resolved already.\r\n\r\n### `promiseValue()`\r\nReads the current value of promise value wrapper object.\r\n\r\n#### Returns:\r\nthe current value of promise value wrapper object: `initialValue` of an object or the value that was used to resolve the Promise.\r\n\r\n### `itDepends.onChange(callback)`\r\nCreates the subscription on a change to any observable value.\r\n\r\n#### Parameters:\r\n* `callback` *(mandatory, function (changed: observableValue, from: any, to: any) -> void )* - the function that will be called immediately when a change is made to any observable value. The callback receives the changed observableValue, old and new value of observable object.\r\n\r\n#### Returns:\r\nthe `subscription` object that can be used to control the subscription.\r\n\r\n### `observableValue.onChange(callback)`\r\nCreates the subscription on a change to this observable value.\r\n\r\n#### Parameters:\r\n* `callback` *(mandatory, function (changed: observableValue, from: any, to: any) -> void )* - the function that will be called immediately when a change is made to this observable value. The callback receives the changed observableValue, old and new value of observable object.\r\n\r\n#### Returns:\r\nthe `subscription` object that can be used to control the subscription.\r\n\r\n### `subscription.disable()`\r\nDisables subscription, so change notifications will stop coming any more, unless it is enabled again with `enable` method.\r\n\r\n#### Returns:\r\n*void*\r\n\r\n### `subscription.enable()`\r\nEnables subscription if it was disabled previously, so change notifications will start coming again.\r\n\r\n#### Returns:\r\n*void*\r\n\r\n## Example code ([Try it in Tonic](https://tonicdev.com/gerichhome/it-depends))\r\n```javascript\r\nvar firstName = itDepends.value('James');\r\nvar lastName  = itDepends.value('Bond');\r\n\r\nvar fullName = itDepends.computed(function(){\r\n    return 'Hello, ' + firstName() + ' ' + lastName();\r\n});\r\n\r\nconsole.log(fullName()); // Hello, James Bond\r\n\r\nfirstName.write('Jack');\r\n\r\nconsole.log(fullName()); // Hello, Jack Bond\r\n```\r\n\r\n## Contributing\r\nI will be glad if you will join the development.\r\n\r\nThere are lot of things you can help me with. Here are few of them:\r\n* Enhance documentation / write samples\r\n* Raise/discuss/prepare PRs for [improvements/issues](https://github.com/gerich-home/it-depends/issues)\r\n* Add more [unit tests](https://github.com/gerich-home/it-depends/tree/master/specs)\r\n* Help me with publishing to different repositories, automate it: npm, Bower, NuGet\r\n* Move to TypeScript / write typings\r\n* Make library known to publicity\r\n\r\n### Contribution Guide\r\n\r\nDevelopment environment prerequisites:\r\n\r\n1. [NodeJS](https://nodejs.org/), [npm](https://www.npmjs.com/)\r\n2. [Gulp](http://gulpjs.com/). Install with: `npm install --global gulp-cli`\r\n\r\nWorkflow:\r\n\r\n1. Create a fork\r\n2. Clone your git repository\r\n3. Run `npm install`\r\n5. Run `gulp`, all tests should be green, build should work\r\n4. Make a code change\r\n5. Run `gulp`, all tests should be green, build should work, fix if failed\r\n6. Commit, push\r\n7. Create PR (pull request)\r\n\r\n\r\n## Author\r\n[Sergey Gerasimov](mailto:gerich.home@gmail.com)\r\n\r\n## License\r\nMSPL (Microsoft Public License)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}